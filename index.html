<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RudyCombat</title>
  <style>
    :root { --bg:#0b0f1a; --card:#121a2b; --txt:#e8eefc; --muted:#9aa7c7; }
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:radial-gradient(1200px 600px at 50% 0%, #162044, var(--bg)); color:var(--txt); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    .card { background:rgba(18,26,43,.88); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }

    .screen { display:none; }
    .screen.active { display:block; }

    .grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap:14px;
      margin-top: 14px;
    }
    .pick { cursor:pointer; transition: transform .08s ease, background .2s ease; user-select:none; }
    .pick:hover { transform: translateY(-2px); }
    .pick:active { transform: translateY(0px); }
    .pick img{
      width:100%;
      height:160px;
      object-fit:cover;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      display:block;
      margin-bottom:10px;
    }
    .pick .name { font-weight:800; letter-spacing:.2px; }
    .pick .desc { font-size: 13px; color: var(--muted); margin-top:4px; }

    .arena { display:grid; grid-template-columns: 1fr 140px 1fr; gap:16px; align-items:center; }
    .fighter { display:flex; flex-direction:column; gap:10px; }
    .toprow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .hptext { font-size: 13px; color: var(--muted); display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .imgbox { background:rgba(255,255,255,.04); border-radius:14px; padding:10px; display:flex; justify-content:center; align-items:center; min-height: 260px; }
    .arena img { width: 100%; max-width: 320px; height: 240px; object-fit: cover; border-radius:12px; border:1px solid rgba(255,255,255,.10); }
    .bar { height: 12px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.10); }
    .bar > div { height:100%; width:100%; background: linear-gradient(90deg, #43f0a5, #3a7bff); transition: width .25s ease; }

    .mid { display:flex; flex-direction:column; align-items:center; gap:10px; }
    .turn { font-size: 13px; color: var(--muted); text-align:center; }

    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-top: 16px; align-items:center; }
    button {
      background:#1b2642; color:var(--txt); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:700;
      transition: transform .05s ease, background .2s ease;
      display:flex; gap:8px; align-items:center;
    }
    button:hover { background:#22305a; }
    button:active { transform: translateY(1px); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .btn-meta { font-size: 12px; color: var(--muted); font-weight:600; }

    .log { margin-top:16px; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px; min-height:110px; }
    .log p { margin: 6px 0; font-size: 14px; color: #d9e3ff; }

    .badges { display:flex; gap:6px; flex-wrap:wrap; }
    .badge {
      font-size:12px; color:#d9e3ff; background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10); padding:3px 8px; border-radius:999px;
    }

    @keyframes shake {
      0% { transform: translate(0,0) rotate(0deg); }
      20% { transform: translate(-6px, 2px) rotate(-1deg); }
      40% { transform: translate(6px, -2px) rotate(1deg); }
      60% { transform: translate(-4px, -1px) rotate(-1deg); }
      80% { transform: translate(4px, 1px) rotate(1deg); }
      100% { transform: translate(0,0) rotate(0deg); }
    }
    .shake { animation: shake .28s ease; }
    .hit { box-shadow: 0 0 0 2px rgba(255,90,90,.6), 0 0 24px rgba(255,90,90,.25); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Pokonaj odwieczne zÅ‚o wybranym bohaterem</h1>

    <!-- SCREEN 1: PICK HERO -->
    <section id="pickScreen" class="screen active">
      <div class="card">
        <div style="font-weight:800; font-size:18px;">Wybierz postaÄ‡</div>
        <div id="pickGrid" class="grid"></div>
      </div>
    </section>

    <!-- SCREEN 2: FIGHT -->
    <section id="fightScreen" class="screen">
      <div class="arena">
        <!-- HERO -->
        <div class="card fighter">
          <div class="toprow">
            <div class="name" id="heroName">Bohater</div>
            <div class="hptext">
              <span id="heroHpText"></span>
              <span class="badge" id="heroShieldBadge" style="display:none;"></span>
              <span class="badge" id="heroStunBadge" style="display:none;">STUN</span>
            </div>
          </div>
          <div class="bar"><div id="heroHpBar"></div></div>
          <div class="badges" id="heroStatusBadges"></div>
          <div class="imgbox">
            <img id="heroImg" alt="Bohater" />
          </div>
        </div>

        <!-- MIDDLE -->
        <div class="mid">
          <div class="turn" id="turnInfo">Twoja tura</div>
          <button id="resetBtn">Reset walki</button>
          <button id="backBtn">ZmieÅ„ postaÄ‡</button>
        </div>

        <!-- ENEMY -->
        <div class="card fighter">
          <div class="toprow">
            <div class="name" id="enemyName">Rudy (Chuj)</div>
            <div class="hptext">
              <span id="enemyHpText"></span>
              <span class="badge" id="enemyShieldBadge" style="display:none;"></span>
              <span class="badge" id="enemyStunBadge" style="display:none;">STUN</span>
            </div>
          </div>
          <div class="bar"><div id="enemyHpBar"></div></div>
          <div class="badges" id="enemyStatusBadges"></div>
          <div class="imgbox">
            <img id="enemyImg" alt="WrÃ³g" src="assets/rudy.png" />
          </div>
        </div>
      </div>

      <!-- Skill buttons are rendered dynamically -->
      <div class="controls card" id="skillBar"></div>

      <div class="log" id="log"></div>
      <!-- MERCY MODAL -->
      <div id="modalOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9999; align-items:center; justify-content:center;">
        <div id="modalBox" style="max-width:520px; width:92%; background:rgba(18,26,43,.96); border:1px solid rgba(255,255,255,.12); border-radius:16px; box-shadow: 0 20px 60px rgba(0,0,0,.6); padding:16px;">
          <div id="modalTitle" style="font-weight:900; font-size:18px; margin-bottom:8px;">TytuÅ‚</div>
          <div id="modalText" style="color:var(--txt); opacity:.92; line-height:1.35; margin-bottom:14px;">
            TreÅ›Ä‡
          </div>
          <div id="modalButtons" style="display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // =========================================================
    // 1) BOHATEROWIE â€“ tu ustawiasz HP + 3 akcje (AA + 2 skille)
    // =========================================================
    // KaÅ¼dy skill to obiekt w skillCatalog, a bohater ma listÄ™ 3 skillId.
    const heroes = [
      {
        id: "saba",
        name: "Saba (BarbarzyÅ„ca)",
        img: "assets/Saba.png",
        maxHp: 140,
        skills: ["aa_saba", "saba_rage", "saba_cleave"]
      },
      {
        id: "pumba",
        name: "Pumba (Mag)",
        img: "assets/pumba.png",
        maxHp: 90,
        skills: ["aa_pumba", "pumba_fireball", "pumba_barrier"]
      },
      {
        id: "klimka",
        name: "Klimka (Druid)",
        img: "assets/klimka.png",
        maxHp: 110,
        skills: ["aa_klimka", "klimka_regrowth", "klimka_poison"]
      },
      {
        id: "kodakajra",
        name: "Koda & Kajra (Åowca & Pet)",
        img: "assets/kodakajra.png",
        maxHp: 135,
        skills: ["aa_kodakajra", "kk_trap", "kk_bite"]
      }
    ];

    // =========================================================
    // 2) KATALOG SKILLI â€“ tu robisz â€œbardziej skomplikowaneâ€
    // =========================================================
    // Mechaniki wspierane: damage, heal, shield, dot, stun, buffDmg
    const skillCatalog = {
      // --- Basic attacks ---
      aa_saba: {
        name: "Cios toporem",
        icon: "ðŸª“",
        cooldown: 0,
        use: (ctx) => {
          const dmg = roll(10, 16) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Cios toporem");
        }
      },
      aa_pumba: {
        name: "Kijem po Å‚bie",
        icon: "ðŸª„",
        cooldown: 0,
        use: (ctx) => {
          const dmg = roll(6, 10) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Kijem po Å‚bie");
        }
      },
      aa_klimka: {
        name: "PnÄ…cza",
        icon: "ðŸŒ¿",
        cooldown: 0,
        use: (ctx) => {
          const dmg = roll(7, 12) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "PnÄ…cza");
        }
      },
      aa_kodakajra: {
        name: "StrzaÅ‚",
        icon: "ðŸ¹",
        cooldown: 0,
        use: (ctx) => {
          const dmg = roll(10, 16) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "StrzaÅ‚");
        }
      },

      // --- Saba skills ---
      saba_rage: {
        name: "SzaÅ‚",
        icon: "ðŸ˜¡",
        cooldown: 3,
        use: (ctx) => {
          ctx.attacker.buffs.dmgFlat += 6;
          ctx.attacker.buffs.dmgBuffTurns = Math.max(ctx.attacker.buffs.dmgBuffTurns, 2);
          log(`ðŸ˜¡ ${ctx.attacker.name} wpada w SzaÅ‚: +6 dmg przez 2 tury.`);
        }
      },
      saba_cleave: {
        name: "RozÅ‚upanie",
        icon: "ðŸ’¥",
        cooldown: 2,
        use: (ctx) => {
          const dmg = roll(16, 24) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "RozÅ‚upanie");
        }
      },

      // --- Pumba skills ---
      pumba_fireball: {
        name: "Kula ognia",
        icon: "ðŸ”¥",
        cooldown: 2,
        use: (ctx) => {
          const dmg = roll(16, 24) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Kula ognia");
          applyDot(ctx.defender, { id:"burn", name:"Burn", icon:"ðŸ”¥", turns: 3, dmgPerTurn: 5 });
          log(`ðŸ”¥ ${ctx.defender.name} pÅ‚onie: 5 dmg przez 3 tury.`);
        }
      },
      pumba_barrier: {
        name: "Bariera",
        icon: "ðŸ›¡ï¸",
        cooldown: 3,
        use: (ctx) => {
          addShield(ctx.attacker, roll(18, 28));
          log(`ðŸ›¡ï¸ ${ctx.attacker.name} stawia barierÄ™ (tarcza).`);
        }
      },

      // --- Klimka skills ---
      klimka_regrowth: {
        name: "Odrost",
        icon: "ðŸŒ±",
        cooldown: 3,
        use: (ctx) => {
          const heal = roll(14, 22);
          healTarget(ctx.attacker, heal);
          applyHot(ctx.attacker, { id:"regrowth", name:"Regrowth", icon:"ðŸŒ±", turns: 2, healPerTurn: 6 });
          log(`ðŸŒ± ${ctx.attacker.name} leczy siÄ™: +${heal} teraz i +6 przez 2 tury.`);
        }
      },
      klimka_poison: {
        name: "Trucizna",
        icon: "â˜ ï¸",
        cooldown: 2,
        use: (ctx) => {
          const dmg = roll(8, 12) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Trucizna");
          applyDot(ctx.defender, { id:"poison", name:"Poison", icon:"â˜ ï¸", turns: 4, dmgPerTurn: 3 });
          log(`â˜ ï¸ ${ctx.defender.name} zatruty: 3 dmg przez 4 tury.`);
        }
      },

      // --- Koda & Kajra skills ---
      kk_trap: {
        name: "PuÅ‚apka",
        icon: "ðŸª¤",
        cooldown: 3,
        use: (ctx) => {
          stun(ctx.defender, 1);
          log(`ðŸª¤ ${ctx.defender.name} wpada w puÅ‚apkÄ™: STUN (1 tura).`);
        }
      },
      kk_bite: {
        name: "Ugryzienie",
        icon: "ðŸº",
        cooldown: 2,
        use: (ctx) => {
          const dmg = roll(10, 14) + ctx.attacker.buffs.dmgFlat;
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Ugryzienie");
          applyDot(ctx.defender, { id:"bleed", name:"Bleed", icon:"ðŸ©¸", turns: 3, dmgPerTurn: 5 });
          log(`ðŸ©¸ ${ctx.defender.name} krwawi: 5 dmg przez 3 tury.`);
        }
      },

      // --- Enemy skills (Rudy) ---
      enemy_bonk: {
        name: "Bonk",
        icon: "ðŸ‘Š",
        cooldown: 0,
        use: (ctx) => {
          const dmg = roll(9, 15);
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Bonk");
        }
      },
      enemy_spit: {
        name: "Plujka",
        icon: "ðŸ¤¢",
        cooldown: 3,
        use: (ctx) => {
          const dmg = roll(10, 14);
          dealDamage(ctx.attacker, ctx.defender, dmg, ctx, "Plujka");
          applyDot(ctx.defender, { id:"slime", name:"Slime", icon:"ðŸŸ¢", turns: 2, dmgPerTurn: 6 });
          log(`ðŸŸ¢ ${ctx.defender.name} oblepiony: 6 dmg przez 2 tury.`);
        }
      }
    };

    // =========================================================
    // Screen helpers
    // =========================================================
    const pickScreen = document.getElementById("pickScreen");
    const fightScreen = document.getElementById("fightScreen");
    const show = (el) => {
      pickScreen.classList.remove("active");
      fightScreen.classList.remove("active");
      el.classList.add("active");
    };

    const FALLBACK_IMG = "https://picsum.photos/seed/fallback/900/600";

    // =========================================================
    // Render pick screen
    // =========================================================
    const pickGrid = document.getElementById("pickGrid");
    function renderPickGrid() {
      pickGrid.innerHTML = "";

      heroes.forEach((h, idx) => {
        const div = document.createElement("div");
        div.className = "card pick";

        div.innerHTML = `
          <img src="${h.img}" alt="${h.name}">
          <div class="name">${h.name}</div>
          <div class="desc">HP: ${h.maxHp} â€¢ Bohater #${idx + 1}</div>
        `;

        const imgEl = div.querySelector("img");
        imgEl.addEventListener("error", () => { imgEl.src = FALLBACK_IMG; });

        div.addEventListener("click", () => startGameWithHero(h));
        pickGrid.appendChild(div);
      });
    }

    // =========================================================
    // Fight state
    // =========================================================
    function makeFighterFromHero(heroDef) {
      return {
        id: heroDef.id,
        name: heroDef.name,
        img: heroDef.img,
        hp: heroDef.maxHp,
        maxHp: heroDef.maxHp,
        skills: [...heroDef.skills],
        cooldowns: {}, // skillId -> turns left
        shield: 0,
        stunned: 0,
        dots: [], // {id,name,icon,turns,dmgPerTurn}
        hots: [], // {id,name,icon,turns,healPerTurn}
        buffs: { dmgFlat: 0, dmgBuffTurns: 0 }
      };
    }

    function makeEnemy() {
      return {
        id: "rudy",
        name: "Rudy (Chuj)",
        img: "assets/rudy.png",
        hp: 160,
        maxHp: 160,
        skills: ["enemy_bonk", "enemy_spit"], // AI wybiera
        cooldowns: {},
        shield: 0,
        stunned: 0,
        dots: [],
        hots: [],
        buffs: { dmgFlat: 0, dmgBuffTurns: 0 }
      };
    }

    const state = {
      hero: null,
      enemy: null,
      turn: "hero",
      busy: false,
      gameOver: false,
      mercyEventDone: false,
    };

    // ===== MERCY MODAL + EVENT =====
const modalOverlay = document.getElementById("modalOverlay");
const modalTitle = document.getElementById("modalTitle");
const modalText = document.getElementById("modalText");
const modalButtons = document.getElementById("modalButtons");

function openModal({ title, text, buttons }) {
  modalTitle.textContent = title;
  modalText.textContent = text;
  modalButtons.innerHTML = "";

  buttons.forEach(b => {
    const btn = document.createElement("button");
    btn.textContent = b.label;
    btn.addEventListener("click", b.onClick);
    modalButtons.appendChild(btn);
  });

  modalOverlay.style.display = "flex";
}

function closeModal() {
  modalOverlay.style.display = "none";
}

// sprawdza czy uruchomiÄ‡ event (tylko raz) i zatrzymuje turÄ™ wroga
async function maybeTriggerMercyEvent() {
  if (state.gameOver) return false;
  if (state.mercyEventDone) return false;
  if (!state.enemy || state.enemy.id !== "rudy") return false;

  const hpPct = state.enemy.hp / state.enemy.maxHp;
  if (hpPct >= 0.10) return false;

  // 20% szans
  if (Math.random() > 0.20) return false;

  state.mercyEventDone = true;
  state.busy = true;
  updateUI();

  // Popup #1
  openModal({
    title: "Rudy bÅ‚aga o litoÅ›Ä‡â€¦",
    text: "Rudy jest na skraju. Patrzy na ciebie i prosi o litoÅ›Ä‡. Co robisz?",
    buttons: [
      {
        label: "ðŸ•Šï¸ OkazujÄ™ litoÅ›Ä‡",
        onClick: () => {
          // Popup #2
          openModal({
            title: "BÅ‚Ä…d.",
            text: "Rudy uÅ›miecha siÄ™ krzywo. W tej samej chwili wbija ci nÃ³Å¼ w plecy. Rudemu nie moÅ¼na ufaÄ‡.",
            buttons: [
              {
                label: "â€¦",
                onClick: () => {
                  closeModal();
                  // natychmiastowa Å›mierÄ‡ gracza
                  state.hero.hp = 0;
                  state.gameOver = true;
                  log("ðŸ—¡ï¸ Rudy zdradza. Giniesz. Koniec gry.");
                  state.busy = false;
                  updateUI();
                }
              }
            ]
          });
        }
      },
      {
        label: "ðŸª“ Nie okazujÄ™ litoÅ›ci",
        onClick: () => {
          closeModal();
          log("ðŸ˜ Nie okazujesz litoÅ›ci. Walka trwa.");
          // zwalniamy blokadÄ™ i pozwalamy turze wroga iÅ›Ä‡ dalej
          state.busy = false;
          updateUI();
        }
      }
    ]
  });

  return true; // event triggered
}
    

    // =========================================================
    // DOM
    // =========================================================
    const heroImg = document.getElementById("heroImg");
    const enemyImg = document.getElementById("enemyImg");
    const heroName = document.getElementById("heroName");
    const heroHpBar = document.getElementById("heroHpBar");
    const enemyHpBar = document.getElementById("enemyHpBar");
    const heroHpText = document.getElementById("heroHpText");
    const enemyHpText = document.getElementById("enemyHpText");
    const heroShieldBadge = document.getElementById("heroShieldBadge");
    const enemyShieldBadge = document.getElementById("enemyShieldBadge");
    const heroStunBadge = document.getElementById("heroStunBadge");
    const enemyStunBadge = document.getElementById("enemyStunBadge");
    const heroStatusBadges = document.getElementById("heroStatusBadges");
    const enemyStatusBadges = document.getElementById("enemyStatusBadges");

    const turnInfo = document.getElementById("turnInfo");
    const logBox = document.getElementById("log");
    const resetBtn = document.getElementById("resetBtn");
    const backBtn = document.getElementById("backBtn");
    const skillBar = document.getElementById("skillBar");

    // =========================================================
    // Utils / effects
    // =========================================================
    const wait = (ms) => new Promise(res => setTimeout(res, ms));
    const roll = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    function barbarianRageBonus(attacker) {
      if (attacker.id !== "saba") return 0; // tylko barbarzyÅ„ca
      const missingPct = (attacker.maxHp - attacker.hp) / attacker.maxHp; // 0..1
      const RAGE_MAX_BONUS = 10; // <-- tu balansujesz (np. 8-14)
      return Math.floor(missingPct * RAGE_MAX_BONUS);
    }

    function log(msg) {
      const p = document.createElement("p");
      p.textContent = msg;
      logBox.appendChild(p);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function animateHit(imgEl) {
      imgEl.classList.remove("shake", "hit");
      void imgEl.offsetWidth;
      imgEl.classList.add("shake", "hit");
      setTimeout(() => imgEl.classList.remove("hit"), 300);
    }

    function clampHp(f) { f.hp = Math.max(0, Math.min(f.hp, f.maxHp)); }

    function addShield(target, amount) {
      target.shield = Math.max(0, target.shield + amount);
    }

    function stun(target, turns) {
      target.stunned = Math.max(target.stunned, turns);
    }

    function applyDot(target, dot) {
      // JeÅ›li juÅ¼ istnieje, odÅ›wieÅ¼ czas i dmg
      const ex = target.dots.find(d => d.id === dot.id);
      if (ex) { ex.turns = Math.max(ex.turns, dot.turns); ex.dmgPerTurn = dot.dmgPerTurn; ex.icon = dot.icon; ex.name = dot.name; return; }
      target.dots.push({...dot});
    }

    function applyHot(target, hot) {
      const ex = target.hots.find(h => h.id === hot.id);
      if (ex) { ex.turns = Math.max(ex.turns, hot.turns); ex.healPerTurn = hot.healPerTurn; ex.icon = hot.icon; ex.name = hot.name; return; }
      target.hots.push({...hot});
    }

    function healTarget(target, amount) {
      target.hp += amount;
      clampHp(target);
    }

    function dealDamage(attacker, defender, amount, ctx, label) {
      const rage = barbarianRageBonus(attacker);
      const total = amount + rage;
      let left = total;

      // shield first
      if (defender.shield > 0) {
        const absorbed = Math.min(defender.shield, left);
        defender.shield -= absorbed;
        left -= absorbed;
        if (absorbed > 0) log(`ðŸ›¡ï¸ Tarcza pochÅ‚ania ${absorbed} dmg.`);
      }

      if (left > 0) {
        defender.hp -= left;
        clampHp(defender);
      }

      // anim
      if (defender === state.enemy) animateHit(enemyImg);
      else animateHit(heroImg);

      if (rage > 0) {
        log(`ðŸ’¢ ${attacker.name} uÅ¼ywa ${label}: -${total} HP (base ${amount} + rage ${rage}).`);
      } else {
        log(`ðŸ’¢ ${attacker.name} uÅ¼ywa ${label}: -${total} HP.`);
      }
    }

    function tickCooldowns(f) {
      for (const k of Object.keys(f.cooldowns)) {
        f.cooldowns[k] = Math.max(0, f.cooldowns[k] - 1);
      }
    }

    function tickDotsAndHots(f) {
      // DoT
      if (f.dots.length) {
        f.dots.forEach(d => {
          f.hp -= d.dmgPerTurn;
          log(`${d.icon} ${f.name} cierpi (${d.name}): -${d.dmgPerTurn} HP`);
          d.turns -= 1;
        });
        f.dots = f.dots.filter(d => d.turns > 0);
        clampHp(f);
      }

      // HoT
      if (f.hots.length) {
        f.hots.forEach(h => {
          f.hp += h.healPerTurn;
          log(`${h.icon} ${f.name} regeneruje (${h.name}): +${h.healPerTurn} HP`);
          h.turns -= 1;
        });
        f.hots = f.hots.filter(h => h.turns > 0);
        clampHp(f);
      }
    }

    function tickBuffs(f) {
      if (f.buffs.dmgBuffTurns > 0) {
        f.buffs.dmgBuffTurns -= 1;
        if (f.buffs.dmgBuffTurns === 0) {
          // zdejmujemy buff flat (u nas tylko SzaÅ‚ dodaje +4)
          // JeÅ›li pÃ³Åºniej dodasz inne buffy â€“ przerobimy to na listÄ™ buffÃ³w.
          f.buffs.dmgFlat = 0;
          log(`âœ¨ Buff dmg na ${f.name} wygasa.`);
        }
      }
    }

    function endIfDead() {
      if (state.enemy.hp <= 0) {
        state.gameOver = true;
        log("ðŸ† WrÃ³g padÅ‚. Wygrywasz!");
        updateUI();
        return true;
      }
      if (state.hero.hp <= 0) {
        state.gameOver = true;
        log("ðŸ’€ Bohater polegÅ‚. WrÃ³g wygrywa.");
        updateUI();
        return true;
      }
      return false;
    }

    // =========================================================
    // UI rendering
    // =========================================================
    function renderSkillButtons() {
      skillBar.innerHTML = "";

      const hero = state.hero;
      hero.skills.forEach((skillId) => {
        const s = skillCatalog[skillId];
        const cdLeft = hero.cooldowns[skillId] || 0;

        const btn = document.createElement("button");
        btn.className = "skillBtn";
        btn.dataset.skill = skillId;

        btn.innerHTML = `
          <span>${s.icon || "âœ¨"}</span>
          <span>${s.name}</span>
          <span class="btn-meta">${s.cooldown ? `CD:${s.cooldown}` : ""}${cdLeft ? ` â€¢ (${cdLeft})` : ""}</span>
        `;

        btn.disabled = state.busy || state.gameOver || state.turn !== "hero" || cdLeft > 0 || state.hero.stunned > 0;

        btn.addEventListener("click", () => onHeroSkill(skillId));
        skillBar.appendChild(btn);
      });

      // info o stun
      if (state.hero && state.hero.stunned > 0) {
        const info = document.createElement("div");
        info.style.color = "var(--muted)";
        info.style.fontSize = "13px";
        info.textContent = "JesteÅ› ogÅ‚uszony â€“ tracisz turÄ™.";
        skillBar.appendChild(info);
      }
    }

    function renderStatuses() {
      const render = (fighter, container) => {
        container.innerHTML = "";
        const list = [
          ...fighter.dots.map(d => `${d.icon} ${d.name}(${d.turns})`),
          ...fighter.hots.map(h => `${h.icon} ${h.name}(${h.turns})`)
        ];
        list.forEach(t => {
          const b = document.createElement("span");
          b.className = "badge";
          b.textContent = t;
          container.appendChild(b);
        });
      };
      render(state.hero, heroStatusBadges);
      render(state.enemy, enemyStatusBadges);

      heroShieldBadge.style.display = state.hero.shield > 0 ? "inline-block" : "none";
      heroShieldBadge.textContent = `ðŸ›¡ï¸ ${state.hero.shield}`;
      enemyShieldBadge.style.display = state.enemy.shield > 0 ? "inline-block" : "none";
      enemyShieldBadge.textContent = `ðŸ›¡ï¸ ${state.enemy.shield}`;

      heroStunBadge.style.display = state.hero.stunned > 0 ? "inline-block" : "none";
      enemyStunBadge.style.display = state.enemy.stunned > 0 ? "inline-block" : "none";
    }

    function updateUI() {
      heroName.textContent = state.hero.name;
      heroImg.src = state.hero.img;
      enemyImg.src = state.enemy.img;

      heroHpBar.style.width = (state.hero.hp / state.hero.maxHp) * 100 + "%";
      enemyHpBar.style.width = (state.enemy.hp / state.enemy.maxHp) * 100 + "%";
      heroHpText.textContent = `${state.hero.hp}/${state.hero.maxHp} HP`;
      enemyHpText.textContent = `${state.enemy.hp}/${state.enemy.maxHp} HP`;

      if (state.gameOver) turnInfo.textContent = "Koniec walki.";
      else if (state.turn === "hero") turnInfo.textContent = "Twoja tura: wybierz akcjÄ™";
      else turnInfo.textContent = "Tura wroga...";

      renderStatuses();
      renderSkillButtons();
    }

    // =========================================================
    // Turn flow
    // =========================================================
    async function startTurn(fighter) {
      tickCooldowns(fighter);
      tickBuffs(fighter);
      tickDotsAndHots(fighter);

      // JeÅ›li DoT zabiÅ‚
      updateUI();
      await wait(250);
      if (endIfDead()) return;

    }

    async function onHeroSkill(skillId) {
      if (state.turn !== "hero" || state.busy || state.gameOver) return;
      if (state.hero.stunned > 0) return;

      const hero = state.hero;
      const enemy = state.enemy;

      const s = skillCatalog[skillId];
      const cdLeft = hero.cooldowns[skillId] || 0;
      if (cdLeft > 0) return;

      state.busy = true;
      updateUI();

      // uÅ¼ycie skilla
      const ctx = { attacker: hero, defender: enemy };
      s.use(ctx);

      // ustaw cooldown
      if (s.cooldown && s.cooldown > 0) hero.cooldowns[skillId] = s.cooldown;

      updateUI();
      await wait(450);

      if (endIfDead()) { state.busy = false; updateUI(); return; }

      state.turn = "enemy";
      updateUI();

      await wait(350);

      // jeÅ›li odpaliÅ‚ siÄ™ event litoÅ›ci, to czekamy aÅ¼ gracz kliknie w modalu
      const mercyTriggered = await maybeTriggerMercyEvent();
      if (state.gameOver) return;

      // jeÅ›li event siÄ™ odpaliÅ‚ i gracz NIE okazaÅ‚ litoÅ›ci, to busy zostanie zdjÄ™te i lecimy dalej
      // jeÅ›li siÄ™ nie odpaliÅ‚, to normalnie wrÃ³g atakuje
      if (!mercyTriggered || (mercyTriggered && !state.busy)) {
        await enemyTurn();
      }

      if (!state.gameOver) state.turn = "hero";
      state.busy = false;

      // start of hero turn effects
      await startTurn(state.hero);
      updateUI();
    }

    async function enemyTurn() {
      const enemy = state.enemy;
      const hero = state.hero;

      await startTurn(enemy);
      if (state.gameOver) return;

      if (enemy.stunned > 0) {
      log(`ðŸ’« ${enemy.name} jest ogÅ‚uszony i traci turÄ™.`);
      enemy.stunned -= 1;           // <-- DOPIERO TU schodzi stun
      updateUI();
      await wait(400);
      return;
    }

      // AI: wybiera skill jeÅ›li off-cd, inaczej bonk
      const options = enemy.skills.filter(id => (enemy.cooldowns[id] || 0) === 0);
      const pick = (options.length ? options : ["enemy_bonk"])[Math.floor(Math.random() * (options.length ? options.length : 1))];
      const s = skillCatalog[pick];

      const ctx = { attacker: enemy, defender: hero };
      s.use(ctx);

      if (s.cooldown && s.cooldown > 0) enemy.cooldowns[pick] = s.cooldown;

      updateUI();
      await wait(450);
      endIfDead();
    }

    // =========================================================
    // Flow: pick hero -> start fight
    // =========================================================
    function resetFight(keepHero = true) {
      const oldHero = state.hero;

      state.hero = keepHero && oldHero ? oldHero : null;
      state.enemy = makeEnemy();
      state.turn = "hero";
      state.busy = false;
      state.gameOver = false;
      state.mercyEventDone = false;
      logBox.innerHTML = "";
      log("ðŸ” Nowa walka! Jedziesz.");

      // start of hero turn effects
      if (state.hero) {
        startTurn(state.hero).then(() => updateUI());
      } else {
        updateUI();
      }
    }

    function startGameWithHero(heroDef) {
      state.hero = makeFighterFromHero(heroDef);
      state.enemy = makeEnemy();
      state.turn = "hero";
      state.busy = false;
      state.gameOver = false;
      logBox.innerHTML = "";
      log(`âš”ï¸ Wchodzisz do walki jako ${state.hero.name}.`);

      show(fightScreen);

      // start of hero turn effects
      startTurn(state.hero).then(() => updateUI());
    }

    // =========================================================
    // Events
    // =========================================================
    resetBtn.addEventListener("click", () => {
      // resetuje walkÄ™, ale zostawia wybranego bohatera
      state.hero = makeFighterFromHero(heroes.find(h => h.id === state.hero.id) || heroes[0]);
      resetFight(true);
      updateUI();
    });

    backBtn.addEventListener("click", () => {
      show(pickScreen);
    });

    // Init
    renderPickGrid();
  </script>
</body>
</html>
